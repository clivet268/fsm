4556
((3) 0 () 1 ((q lib "fsm/main.rkt")) () (h ! (equal) ((c form c (c (? . 0) q alphabet)) q (134 . 2)) ((c form c (c (? . 0) q LM)) q (87 . 2)) ((c form c (c (? . 0) q dfa-rule)) q (175 . 2)) ((c def c (c (? . 0) q sm->grammar)) q (3493 . 3)) ((c form c (c (? . 0) q grammar)) q (459 . 2)) ((c form c (c (? . 0) q START)) q (110 . 2)) ((c form c (c (? . 0) q dfa-configuration)) q (256 . 2)) ((c def c (c (? . 0) q singleton-regexp)) q (4596 . 3)) ((c form c (c (? . 0) q ctmd)) q (505 . 2)) ((c def c (c (? . 0) q grammar->sm)) q (1885 . 3)) ((c def c (c (? . 0) q sm-type)) q (2305 . 3)) ((c form c (c (? . 0) q regexp)) q (356 . 2)) ((c def c (c (? . 0) q los->symbol)) q (4999 . 3)) ((c def c (c (? . 0) q combine-tms)) q (4391 . 4)) ((c form c (c (? . 0) q sm)) q (435 . 2)) ((c def c (c (? . 0) q ctm-run)) q (4472 . 5)) ((c def c (c (? . 0) q both-testequiv)) q (4133 . 5)) ((c form c (c (? . 0) q csrule)) q (421 . 2)) ((c form c (c (? . 0) q Derivation)) q (487 . 2)) ((c form c (c (? . 0) q smrule)) q (445 . 2)) ((c form c (c (? . 0) q ARROW)) q (0 . 2)) ((c def c (c (? . 0) q sm-getstates)) q (1938 . 3)) ((c form c (c (? . 0) q tm-action)) q (224 . 2)) ((c form c (c (? . 0) q cfrule)) q (407 . 2)) ((c def c (c (? . 0) q make-tm)) q (1159 . 8)) ((c form c (c (? . 0) q LEFT)) q (75 . 2)) ((c form c (c (? . 0) q pda-rule)) q (208 . 2)) ((c def c (c (? . 0) q make-dfa)) q (517 . 7)) ((c def c (c (? . 0) q grammar-rename-nts)) q (3546 . 3)) ((c def c (c (? . 0) q sm-getfinals)) q (2170 . 3)) ((c def c (c (? . 0) q sm-concat)) q (1643 . 4)) ((c def c (c (? . 0) q sm-getstackalphabet)) q (2232 . 3)) ((c def c (c (? . 0) q both-derive)) q (4032 . 5)) ((c def c (c (? . 0) q generate-symbol)) q (5201 . 4)) ((c form c (c (? . 0) q pda-configuration)) q (307 . 2)) ((c def c (c (? . 0) q ndfa->regexp)) q (4882 . 3)) ((c def c (c (? . 0) q grammar-getalphabet)) q (3678 . 3)) ((c form c (c (? . 0) q DEAD)) q (51 . 2)) ((c form c (c (? . 0) q grule)) q (474 . 2)) ((c form c (c (? . 0) q nts)) q (383 . 2)) ((c def c (c (? . 0) q symbol->list)) q (5065 . 3)) ((c def c (c (? . 0) q sm-union)) q (1578 . 4)) ((c def c (c (? . 0) q make-csg)) q (3170 . 6)) ((c def c (c (? . 0) q make-cfg)) q (3018 . 6)) ((c def c (c (? . 0) q sm-apply)) q (2353 . 5)) ((c def c (c (? . 0) q printable-regexp)) q (4938 . 3)) ((c def c (c (? . 0) q make-ndpda)) q (918 . 8)) ((c def c (c (? . 0) q symbol-upcase)) q (5297 . 3)) ((c def c (c (? . 0) q sm-kleenestar)) q (1709 . 3)) ((c form c (c (? . 0) q ndfa-rule)) q (191 . 2)) ((c form c (c (? . 0) q rrule)) q (394 . 2)) ((c def c (c (? . 0) q sm-testequiv?)) q (2752 . 5)) ((c def c (c (? . 0) q sm-intersection)) q (1813 . 4)) ((c def c (c (? . 0) q grammar-concat)) q (3407 . 4)) ((c form c (c (? . 0) q GOTO)) q (63 . 2)) ((c def c (c (? . 0) q symbol->fsmlos)) q (5132 . 3)) ((c form c (c (? . 0) q terms)) q (370 . 2)) ((c form c (c (? . 0) q state)) q (162 . 2)) ((c form c (c (? . 0) q BRANCH)) q (26 . 2)) ((c def c (c (? . 0) q grammar-test)) q (4263 . 5)) ((c form c (c (? . 0) q BLANK)) q (13 . 2)) ((c def c (c (? . 0) q sm-rename-states)) q (1490 . 4)) ((c def c (c (? . 0) q ndfa->dfa)) q (1386 . 3)) ((c form c (c (? . 0) q word)) q (150 . 2)) ((c def c (c (? . 0) q grammar-getnts)) q (3611 . 3)) ((c def c (c (? . 0) q grammar-union)) q (3322 . 4)) ((c def c (c (? . 0) q make-ndfa)) q (716 . 7)) ((c form c (c (? . 0) q tm-rule)) q (241 . 2)) ((c def c (c (? . 0) q regexp->ndfa)) q (1435 . 3)) ((c def c (c (? . 0) q sm-sameresult?)) q (2658 . 5)) ((c def c (c (? . 0) q sm-getalphabet)) q (2000 . 3)) ((c def c (c (? . 0) q sm-getrules)) q (2057 . 3)) ((c def c (c (? . 0) q sm-test)) q (2564 . 4)) ((c def c (c (? . 0) q concat-regexp)) q (4738 . 4)) ((c form c (c (? . 0) q EMP)) q (40 . 2)) ((c form c (c (? . 0) q VAR)) q (123 . 2)) ((c def c (c (? . 0) q grammar-getrules)) q (3745 . 3)) ((c form c (c (? . 0) q ndfa-configuration)) q (281 . 2)) ((c def c (c (? . 0) q grammar-gettype)) q (3875 . 3)) ((c def c (c (? . 0) q sm-complement)) q (1761 . 3)) ((c def c (c (? . 0) q sm-showtransitions)) q (2440 . 5)) ((c form c (c (? . 0) q tm-configuration)) q (332 . 2)) ((c def c (c (? . 0) q grammar-derive)) q (3936 . 4)) ((c def c (c (? . 0) q empty-regexp)) q (4559 . 2)) ((c def c (c (? . 0) q sm-getstart)) q (2119 . 3)) ((c def c (c (? . 0) q grammar-getstart)) q (3816 . 3)) ((c def c (c (? . 0) q union-regexp)) q (4657 . 4)) ((c def c (c (? . 0) q make-rg)) q (2869 . 6)) ((c form c (c (? . 0) q RIGHT)) q (97 . 2)) ((c def c (c (? . 0) q kleenestar-regexp)) q (4820 . 3))))
syntax
ARROW
syntax
BLANK
syntax
BRANCH
syntax
EMP
syntax
DEAD
syntax
GOTO
syntax
LEFT
syntax
LM
syntax
RIGHT
syntax
START
syntax
VAR
syntax
alphabet
syntax
word
syntax
state
syntax
dfa-rule
syntax
ndfa-rule
syntax
pda-rule
syntax
tm-action
syntax
tm-rule
syntax
dfa-configuration
syntax
ndfa-configuration
syntax
pda-configuration
syntax
tm-configuration
syntax
regexp
syntax
terms
syntax
nts
syntax
rrule
syntax
cfrule
syntax
csrule
syntax
sm
syntax
smrule
syntax
grammar
syntax
grule
syntax
Derivation
syntax
ctmd
procedure
(make-dfa sts sigma start finals delta) -> dfa
  sts : (listof state)
  sigma : alphabet
  start : state
  finals : (listof state)
  delta : (listof dfa-rule)
procedure
(make-ndfa sts sigma start finals delta) -> ndfa
  sts : (listof state)
  sigma : alphabet
  start : state
  finals : (listof state)
  delta : (listof ndfa-rule)
procedure
(make-ndpda sts sigma gamma start finals delta) -> ndpda
  sts : (listof state)
  sigma : alphabet
  gamma : (listof symbol)
  start : state
  finals : (listof state)
  delta : (listof pda-rule)
procedure
(make-tm sts sigma start finals delta accept) -> tm
  sts : (listof state)
  sigma : alphabet
  start : state
  finals : (listof state)
  delta : (listof ndfa-rule)
  accept : state
procedure
(ndfa->dfa m) -> dfa
  m : ndfa
procedure
(regexp->ndfa r) -> ndfa
  r : regexp
procedure
(sm-rename-states sts m1) -> sm
  sts : (listof state)
  m1 : sm
procedure
(sm-union m1 m2) -> sm
  m1 : sm
  m2 : sm
procedure
(sm-concat m1 m2) -> sm
  m1 : sm
  m2 : sm
procedure
(sm-kleenestar m1) -> sm
  m1 : sm
procedure
(sm-complement m1) -> sm
  m1 : sm
procedure
(sm-intersection m1 m2) -> sm
  m1 : sm
  m2 : sm
procedure
(grammar->sm g) -> sm
  g : grammar
procedure
(sm-getstates m) -> (listof state)
  m : sm
procedure
(sm-getalphabet m) -> alphabet
  m : sm
procedure
(sm-getrules m) -> (listof smrule)
  m : sm
procedure
(sm-getstart m) -> state
  m : sm
procedure
(sm-getfinals m) -> (listof state)
  m : sm
procedure
(sm-getstackalphabet m) -> (listof symbol)
  m : ndpda
procedure
(sm-type m) -> symbol
  m : sm
procedure
(sm-apply m w n) -> symbol
  m : sm
  w : word
  n : natnum
procedure
(sm-showtransitions m w n) -> (or (listof smconfig) 'reject)
  m : sm
  w : word
  n : natnum
procedure
(sm-test m1 n) -> (listof (list word symbol))
  m1 : sm
  n : natnum
procedure
(sm-sameresult? m1 m2 w) -> boolean
  m1 : sm
  m2 : sm
  w : word
procedure
(sm-testequiv? m1 m2 n) -> (or boolean (listof word))
  m1 : sm
  m2 : sm
  n : natnum
procedure
(make-rg nt sigma delta start) -> rg
  nt : (listof nts)
  sigma : alphabet
  delta : (listof rrule)
  start : nts
procedure
(make-cfg nt sigma delta start) -> cfg
  nt : (listof nts)
  sigma : alphabet
  delta : (listof cfrule)
  start : nts
procedure
(make-csg nt sigma delta start) -> csg
  nt : (listof nts)
  sigma : alphabet
  delta : (listof csrule)
  start : nts
procedure
(grammar-union g1 g2) -> grammar
  g1 : grammar
  g2 : grammar
procedure
(grammar-concat g1 g2) -> grammar
  g1 : grammar
  g2 : grammar
procedure
(sm->grammar m) -> grammar
  m : sm
procedure
(grammar-rename-nts g) -> grammar
  g : grammar
procedure
(grammar-getnts g) -> (listof nts)
  g : grammar
procedure
(grammar-getalphabet g) -> alphabet
  g : grammar
procedure
(grammar-getrules g) -> (listof grule)
  g : grammar
procedure
(grammar-getstart g) -> nts
  g : grammar
procedure
(grammar-gettype g) -> symbol
  g : grammar
procedure
(grammar-derive g w) -> (or Derivation string)
  g : grammar
  w : word
procedure
(both-derive g1 g2 w) -> boolean
  g1 : grammar
  g2 : grammar
  w : word
procedure
(both-testequiv g1 g2 natnum) -> (or true (listof word))
  g1 : grammar
  g2 : grammar
  natnum : n
procedure
(grammar-test g1 natnum)
 -> (listof (cons word (Derivation or string)))
  g1 : grammar
  natnum : n
procedure
(combine-tms d sigma) -> ctm
  d : ctmd
  sigma : alphabet
procedure
(ctm-run m w i) -> list
  m : ctm
  w : tmtape
  i : natnum
procedure
(empty-regexp) -> regexp
procedure
(singleton-regexp a) -> regexp
  a : letter
procedure
(union-regexp r1 r2) -> regexp
  r1 : regexp
  r2 : regexp
procedure
(concat-regexp r1 r2) -> regexp
  r1 : regexp
  r2 : regexp
procedure
(kleenestar-regexp r) -> regexp
  r : regexp
procedure
(ndfa->regexp m) -> reg-exp
  m : ndfa
procedure
(printable-regexp r) -> string
  r : regexp
procedure
(los->symbol l) -> symbol
  l : (listof symbol)
procedure
(symbol->list s) -> (listof symbol)
  s : symbol
procedure
(symbol->fsmlos s) -> (listof symbol)
  s : symbol
procedure
(generate-symbol seed l) -> symbol
  seed : symbol
  l : (listof symbol)
procedure
(symbol-upcase s) -> symbol
  s : symbol
